---
title: "Iteration"
format:
  html: default
editor_options: 
  chunk_output_type: console
---

You can download this .qmd file from [here](https://github.com/proback/264_fall_2024/blob/main/06_iteration.qmd).  Just hit the Download Raw File button.

This leans on parts of R4DS Chapter 26: Iteration, in addition to parts of the first edition of R4DS.

```{r}
#| message: false
#| warning: false

# Initial packages required
library(tidyverse)
```


## Iteration

Reducing duplication of code will reduce errors and make debugging much easier.  We've already seen how functions (Ch 25) can help reduce duplication by extracting repeated patterns of code.  Another tool is **iteration**, when you find you're doing the same thing to multiple inputs -- repeating the same operation on different columns or datasets.  

Here we'll see two important iteration paradigms: imperative programming and functional programming.

### Imperation programming for iteration

Examples: for loops and while loops

Pros: relatively easy to learn, make iteration very explicit so it's obvious what's happening, not as inefficient as some people believe

Cons: require lots of bookkeeping code that's duplicated for every loop


Every for loop has three components:

1. output - plan ahead and allocate enough space for output
2. sequence - determines what to loop over; cycles through different values of $i$
3. body - code that does the work; run repeatedly with different values of $i$

```{r}
#| error: TRUE

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
df

# want median of each column (w/o cutting and pasting)
#   Be careful using square brackets vs double square brackets when
#   selecting elements
median(df[[1]])
median(df[1])

df[1]
df[[1]]

class(df[1])
class(df[[1]])

# basic for loop to take median of each column
output <- vector("double", ncol(df))  # 1. output
for (i in 1:4) {                      # 2. sequence
  output[[i]] <- median(df[[i]])      # 3. body
}
output

# ?seq_along - a safer option if had zero length vectors
output <- vector("double", ncol(df))  # 1. output
for (i in seq_along(df)) {            # 2. sequence
  output[[i]] <- median(df[[i]])      # 3. body
}
output
# use [[.]] even if don't have to to signal working with single elements

# alternative solution - don't hardcode in "4"
output <- vector("double", ncol(df))  # 1. output
for(i in 1:ncol(df)) {                # 2. sequence
  output[i] <- median(df[[i]])        # 3. body
}
output

# another approach - no double square brackets since df not a tibble
df <- as.data.frame(df)
output <- vector("double", ncol(df))  # 1. output
for(i in 1:ncol(df)) {                # 2. sequence
  output[i] <- median(df[,i])         # 3. body
}
output
```

One advantage of `seq_along()`: works with unknown output length.  However, the second approach below is much more efficient, since each iteration doesn't copy all data from previous iterations.

**[Pause to Ponder:]** What does the code below do?  Be prepared to explain both chunks line-by-line!

```{r}
# for loop: unknown output length

means <- c(0, 1, 2)
output <- double()
for (i in seq_along(means)) {
  n <- sample(100, 1)
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)        ## inefficient

out <- vector("list", length(means))
for (i in seq_along(means)) {
  n <- sample(100, 1)
  out[[i]] <- rnorm(n, means[[i]])
}
str(out)           ## more efficient
str(unlist(out))   ## flatten list of vectors into single vector
```

Finally, the `while()` loop can be used with unknown sequence length.  This is used more in simulation than in data analysis.

**[Pause to Ponder:]** What does the following code do?

```{r}
flip <- function() sample(c("T", "H"), 1)
flips <- 0
nheads <- 0
while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips
```


### Functional programming for iteration

Examples: map functions and across()

Pros: less code, fewer errors, code that's easier to read; takes advantage of fact that R is a functional programming language

Cons: little more complicated to master vocabulary and use -- a step up in abstraction


R is a functional programming language. This means that itâ€™s possible to wrap up for loops in a function, and call that function instead of using the for loop directly.  Passing one function to another is a very powerful coding approach!!

```{r}
# Below you can avoid writing separate functions for mean, median, 
#   SD, etc. by column
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}
col_summary(df, median)
col_summary(df, mean)
col_summary(df, IQR)
```


The `purrr` package provides `map` functions to eliminate need for for loops, plus it makes code easier to read!

```{r}
# using map functions for summary stats by column as above
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
map_dbl(df, mean, trim = 0.5)

# map_dbl means make a double vector
# can also do map() for list, map_lgl(), map_int(), and map_chr()

# even more clear
df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)
```

The across() function from dplyr also works well:

```{r}
df |> summarize(
  n = n(),
  across(.cols = a:d, .fns = median, .names = "median_{.col}")
)

# And if we're worried about NAs
df_miss <- df
df_miss[2, 1] <- NA
df_miss[4:5, 2] <- NA
df_miss |> 
  summarize(
    across(
      a:d,
      list(
        median = \(x) median(x, na.rm = TRUE),
        n_miss = \(x) sum(is.na(x))
      ),
      .names = "{.fn}_{.col}"
    ),
    n = n(),
  )
# where \ is shorthand for an anonymous function
```

pivot_longer() with group_by() and summarize() also provides a nice solution:

```{r}
long <- df |> 
  pivot_longer(a:d) |> 
  group_by(name) |> 
  summarize(
    median = median(value),
    mean = mean(value)
  )
long
```


Here are a couple of other nice features of `map` functions:
 - perform analyses (like fitting a line) by subgroup
 - extracting components from a model or elements by position

```{r}
# fit linear model to each group based on cylinder
#   - split designed to split into new dfs (unlike group_by)
#   - map returns a vector or list, which can be limiting
map = purrr::map
models <- as_tibble(mtcars) %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))
models
models[[1]]

# shortcut using purrr - 1-sided formulas
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))
models

# extract named components from each model
str(models)
str(models[[1]])
str(summary(models[[1]]))
models %>% 
  map(summary) %>% 
  map_dbl("r.squared")

# can use integer to select elements by position
x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)
```


## On Your Own

1. Compute the mean of every column of the `mtcars` data set using (a) a for loop, (b) a `map` function, (c) the across() function, and (d) pivot_longer().


2. Write a function that prints the mean of each *numeric* column in a data frame.  Try it on the `iris` data set. (Hint: `keep(is.numeric)`)


3. Eliminate the for loop in each of the following examples by taking advantage of an existing function that works with vectors:

```{r}
out <- ""
for (x in letters) {
  out <- stringr::str_c(out, x)
}
out


x <- runif(100)
out <- vector("numeric", length(x))
out[1] <- x[1]
for (i in 2:length(x)) {
  out[i] <- out[i - 1] + x[i]
}
out

```


4. Compute the number of unique values in each column of the `iris` data set using at least 2 of your favorite iteration methods.  Bonus points if you can use pivot_longer()!

